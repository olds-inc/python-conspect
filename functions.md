# Функции и их свойства

Функции в python являются объектами первого класса

```python
# пример функции без аргументов
def say_hello():
    print('hello')


# аргументы функций могут иметь значения по-умолчанию
def say_goodbye(name, times=3):
    for _ in range(times):
        print(f'goodbye {name}')


# однако мы можем их переопределять
say_goodbye('anon', times=5)


# если мы используем *args, он должен быть последним аргументом функции
def take_positional(name, *args):
    print(name)
    print(args)  # tuple


take_positional('anon', *[1, 2, 3, 4])


# если мы используем *kwargs, он должен быть последним аргументом функции
def take_keywords(name, **kwargs):
    print(name)
    print(kwargs)  # dict


take_keywords('anon', **{'xxx': 'anon', 'something': 767})
# если в распаковываемом словаре будет ключ с таким же именем как аргумент функции (в нашем случае name) мы получим ошибку got multiple values for argument 'name'
take_keywords('anon', **{'name': 'anon', 'something': 767})
```

## _*args_

Если мы хотим чтобы наша функция корректно работала с произвольным числом _позиционных аргументов_, мы можем указать ключевое слово `*args` как принимаемый ею аргумент, это значит что все передаваемые при вызове функции аргументы будут _автоматически упакованы в кортеж_ и доступны по имени `args`

```python
def sum_all_nums(*args):
    return sum(args)

def sum_all_nums(*words):
    for word in words:
        print word
```

И вызывается она следующим образом:

```python
print(sum_all_nums(1, 2, 3, 4, 5))  #  args = tuple (1, 2, 3, 4, 5)
print(sum_all_nums(1))  #  args = tuple (1)
```

Однако нужно помнить, что если мы передаем список в функцию принимающую произвольное число позиционных аргументов, автоматически он не распаковывается и мы получаем не то, что хотели:

```python
print(sum_all_nums([1, 2, 3, 4, 5]))  #  args = tuple ([1, 2, 3, 4, 5])
print(sum_all_nums([1]))  #  args = tuple ([1])
```

Если мы хотим чтобы список превратился в позиционные аргументы, мы должны распаковать его с помощью `*`:

```python
print(sum_all_nums(*[1, 2, 3, 4, 5]))  #  args = tuple (1, 2, 3, 4, 5)
print(sum_all_nums(*[1]))  #  args = tuple (1)
```

С помощью распаковки в подобные функции можно передавать генераторы в виде, допустим `generate_num` возвращает числа в интервале \[1, 6\]:

```python
print(sum_all_nums(*generate_num()))  # 15
```

Но в целом такая практика считается нежелательной, т.к генераторы используются чтобы возвращать значения по требованию, и распаковка генератора содержащего очень много значений может привести к серьезным проблемам с расходом памяти вашей программой

## _**kwargs_

Если мы хотим чтобы наша функция корректно работала с произвольным числом _именованных аргументов_, мы можем указать ключевое слово `**kwargs` как принимаемый ею аргумент, это значит что все передаваемые при вызове функции аргументы будут _автоматически упакованы в словарь_ и доступны по имени `kwargs` (_keyword args_)

```python
def show_key_value(**kwargs):
    print(kwargs)
```

И вызывается она следующим образом:

```python
show_key_value(arg_one=1, arg_two=2, hello=543, something={'ss': 1})  # kwargs = {'arg_one': 1, 'arg_two': 2, 'hello': 543, 'somethin': {'ss': 1}}
```

Если мы хотим чтобы словарь превратился в именованные аргументы, мы должны распаковать его с помощью `*`:

```python
show_key_value(**{'ss': 1, 'asdasd': 666})  # {'ss': 1, 'asdasd': 666}
```

## Лямбда функции

Синтаксис лямбда функций: 

```python
lambda x: x + 1
```

Например, использование функции __map__ чтобы превратить все числа в списке в строки:

```python
numbers = [1, 2, 3, 4, 5, 6]
strings = list(map(lambda num: str(num), numbers))
```

## Декораторы

Механизм декорации функций используется когда мы можем выделить какой-то общий функционал из разных функций и описать его в декораторе, после чего декорировать функции, например логирование

Простой декоратор без аргументов принимает оборачиваемую функцию и возвращает функцию обертку над ней в общем видел выглядит это так, если оборачиваемая функция содержит аргументы, мы должны передать их через замыкание с помощью `*args` и `**kwargs`:

```python
def decorator(func):
    def wrapper(*args, **kwargs):
        # какие-то действия для которых был создан декоратор
        # например логирование времени вызова функции и т.п
        return func(*args, **kwargs)
    return wrapper
```

Если декоратор принимает какие-либо аргументы, его структура выглядит немного сложнее, в этом случае мы создаем, еще одну обертку над возвращаемой оберткой:

```python
def decorator(arg):
    # как-то обрабатываем аргументы переданные в декоратор
    def outer(func):
        def wrapper(*args, **kwargs):
            # какие-то действия для которых был создан декоратор
            # например логирование времени вызова функции и т.п
            return func(*args, **kwargs)
        return wrapper
    return outer
```

Пример использования, мы помечаем с помощью синтаксического сахара функцию которую хотим обернуть:

```python
@decorator
def say_hello(num):
    print('hello')
    return num
```

Без использования `@decorator` это выглядело бы так:

```python
wrapper = decorator(say_hello)  # func wrapper
result = wrapper(10)  # 10
```
